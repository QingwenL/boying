# 管理员登录模块

该模块为所有管理员通用登录模块,没太多的权限认证

## 登录功能

+ 传入用户名,密码参数
+ 
+ 先根据缓存获取用户信息
+ 缓存不存在则去数据库中寻找,以`username`为查找条件
+ 放入缓存中,键值对为`username,admin`,并且返回`admin`
+ 
+ 如果`admin`不为空,再根据`adminId`把用户的权限也查询出来,放入`AdminUserDetails`
+ 查询权限时,先在缓存中查询,根据adminId,获取权限列表
+ 如果不存在,则在数据库中查询(用到自己写的`adminRoleDao`)
+ 其中权限不包含禁用的角色的权限
+ 把用户拥有的权限放入缓存中,键值对为`adminId,resourceList`
+ 
+ 将参数密码与实际的加密的密码对比判断
+ 判断用户状态是否可用
+ 存储用户信息和拥有的权限
+ 登录成功则生成并返回token
+ 修改登录时间

## 刷新token

+ 如果`token`过期或者在30分钟之内刚刷新过，则不进行操作
+ 否则通过原先的`token`的用户信息和当前的时间新生成一个`token`

## 获取管理员信息

+ 使用`Principal`防止没登录时报错
+ 获取当前登录的管理员
+ 返回用户名,头像,该管理员的菜单,拥有的角色
+ 拥有的角色不包含被禁用的角色
+ 权限不包含禁用的角色的权限,与登录一样,先通过缓存查询资源权限信息
+ 
+ 查询拥有的菜单,使用自定义的`dao`进行多表查询

## 获取当前登录管理员的菜单信息

+ 判断是否登录
+ 传入当前登录用户`adminId`
+ 返回`Map`结构的树形管理员菜单信息,以用于前端动态生成菜单

## 修改密码

+ 传入用户名,旧密码,新密码

+ 校验字段是否为空

+ 校验用户名是否存在

+ 校验密码是否正确

+ 把新密码变为加密状态

+ 更新信息

+ 删除管理员缓存信息

+ 根据更新状态返回对应信息

## 修改自身信息

+ 使用`Principal`防止没登录时报错
+ 获取当前登录的管理员
+ 传入`自己的管理员id`和管理员信息
+ 其中`status`不能改变
+ 设置传入的管理员id为相应的id,并且拷贝相关属性
+ 对数据库应用更新
+ 缓存中删除对应用户信息
+ 返回更新信息

# 管理员模块

## 注册功能

+ 传入`AdminParam`对象,其中用户名,密码不能为空,并进行参数校验
+ 封装相关参数到管理员
+ 判断是否有重名用户
+ 密码加密
+ 插入到数据库
+ 根据`admin`是否为`null`,返回相应注册成功/失败信息



## 批量查询管理员

+ 分页查询
+ 如果传入的关键词不为空,则使用`like`对用户名进行模糊查询

## 获取管理员信息

+ 根据管理员`id`在数据库中通过主键获取信息

+ 查不到则返回错误提示

+ 另外还返回用户的菜单,角色,资源信息

	

## 更新管理员信息

+ 传入`id`和管理员信息
+ 设置传入的管理员id为相应的id,并且拷贝相关属性
+ 对数据库应用更新
+ 缓存中删除对应用户信息
+ 返回更新信息

## 修改密码

+ 传入用户名,新密码

+ 校验字段是否为空

+ 校验用户名是否存在

+ 把新密码变为加密状态

+ 更新信息

+ 删除管理员缓存信息

+ 根据更新状态返回对应信息

	

## 删除管理员

+ 判断要删除管理员账号是否为当前账号，是返回失败原因
+ 删除管理员缓存
+ 删除管理员资源缓存
+ 通过主键删除

## 修改账号状态

+ 设置状态
+ 根据前面的update函数进行更新

## 给管理员分配角色

+ 传入管理员id,角色Id集合
+ 判断角色Id集合是否存在
+ 先判断管理员是否存在
+ 删除管理员之前的角色分配
+ 角色对应的管理员人数-1
+ 判断角色id列表是否都是存在与数据库中的
+ 批量插入角色
+ 对应角色管理员人数+1
+ 删除管理员缓存中的权限缓存

## 删除管理员角色

+ 传入管理员id,角色Id集合
+ 判断角色Id集合是否存在
+ 判断管理员是否存在
+ 删除管理员之前的角色分配
+ 角色对应的管理员人数-1
+ 判断角色id列表是否都是存在与数据库中的
+ 删除管理员缓存中的权限缓存

## 获取管理员角色

+ 先判断管理员是否存在
+ 在自定义的`dao`中,根据`adminId`获取`roleList`

# 菜单模块

## 添加菜单

+ 传入`param`
+ 检查重名菜单
+ 检查parentId是否是0或者对应的父级菜单存在
+ 设置`hidden`属性为false
+ 设置创建时间
+ 更新级别:若他没有父级菜单,则菜单等级为0,否则为父级菜单+1

## 修改菜单

+ 传入id,和要修改的信息
+ 检查id是否存在
+ 检查重名菜单
+ 检查parentId是否是0或者对应的父级菜单存在
+ 一级菜单不能再修改parentId
+ 更新菜单级别
+ 通过`updateByPrimaryKeySelective`更新

## 获取菜单信息

+ 根据Id获取

## 删除菜单

+ 根据Id删除
+ 如果parentId=0,还要查找他有没有子菜单,没有才能删除

## 分页查询后台菜单

+ 分页查询
+ 根据`sort`降序
+ 根据`parentId`进行查询,所以可以查所有一级菜单,也可以查某一级菜单的所有二级菜单

## 返回所有菜单信息

+ 树形结构返回所有菜单列表,便于前端操作
+ 先查询出一级菜单,并且按`sort`排序
+ 以(一级菜单,该一级菜单对应的二级菜单)为键值对存入`Map`进行返回

## 修改菜单状态

+ 传入`id`与`hidden`
+ 修改`hidden`

# 后台资源分类

## 查询所有后台资源分类

+ 直接查询后台资源分类
+ 根据`sort`降序排列

## 添加后台资源分类

+ 传入`param`,包含名称和排序级别
+ 不能创建同名的资源分类
+ 设置创建日期
+ 通过`insertSelective`在数据库中创建,以防止`null`把默认值给修改了

## 修改后台资源分类

+ 传入`param`,包含名称和排序级别
+ 检查id是否存在
+ 不能修改除自身外同名的资源分类
+ 设置`id`为要修改的`id`
+ 根据`updateByPrimaryKeySelective`进行更新

## 根据ID删除后台资源分类

+ 根据主键进行删除
+ 若没有删除任何一条记录,则返回错误提示

## 获取资源分类详情

+ 根据`id`获取后台资源详情

# 后台资源

## 添加后台资源

+ 传入`param`,包含所属的资源分类,资源名称,url,描述
+ 判断后台资源分类是否存在
+ 判断资源名称是否重复
+ 设置创建日期
+ 在数据库中创建
+ 删除后台资源缓存,以便实现权限控制

## 修改后台资源

+ 传入`param`
+ 判断后台资源分类是否存在
+ 判断资源名称是否重复(注意先排除要修改的那个,不然改不了了)
+ 设置`id`为要修改的`id`
+ 根据`updateByPrimaryKeySelective`进行更新
+ 删除缓存中包含该资源的后台管理员相关信息
+ 删除后台资源缓存,以便实现权限控制

## 查询后台资源详情

+ 根据`id`获取后台资源

## 根据ID删除后台资源

+ 根据主键进行删除
+ 删除缓存中包含该资源的后台管理员相关信息
+ 清空资源缓存
+ 若没有删除任何一条记录,则返回错误提示

## 分页模糊查询后台资源

+ 分页查询
+ 根据名称,`Id`或`url`对资源进行模糊查询(对不为空的字段进行)

## 查询所有后台资源

+ 直接查询后台资源

# 后台角色模块

## 添加角色

+ 传入`param`,包含角色名称,描述,状态,`sort`字段
+ 不能添加同名角色
+ 设置对应的管理员用户为0,启用状态为`true`

##  修改角色

+ 传入`param`,包含角色名称,描述,状态,`sort`字段
+ 不能修改角色名与其他的同名
+ `updateByPrimaryKeySelective`

## 删除角色

+ `deleteByPrimaryKey`
+ 删除有相关角色的相关后台管理员缓存

## 批量删除角色

+ 传入角色列表
+ 校验要删除的角色是否都存在
+ 删除相关后台管理员缓存

## 获取所有角色

+ 直接无条件`selectByExample`

## 根据关键词分页获取角色列表

+ 开启分页
+ 如果传入了关键词则通过`like`进行模糊搜索

## 修改角色状态

+ 单独一个函数修改状态,避免和之前的校验冲突
+ 删除与该角色相关的管理员的资源缓存
+ 通过`updateByPrimaryKeySelective`进行修改

## 获取角色相关菜单

+ 判断角色存在
+ 通过自定义`dao`的`getMenuListByRoleId`方法获取

## 获取角色相关资源

+ 判断角色存在
+ 通过自定义`dao`的`getResourceListByRoleId`方法获取

## 分配菜单

+ 判断角色存在
+ 删除原有的关系
+ 判断要分配的菜单是否都存在与数据库中
+ 批量插入新关系

## 分配资源

+ 判断角色存在
+ 删除原有的关系
+ 判断要分配的资源是否都存在与数据库中
+ 批量插入新关系